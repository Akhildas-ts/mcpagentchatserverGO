#!/usr/bin/env node
// Main entry point for the MCP directory - save this as "index.js" in the root of mcp-agent-chat directory

import readline from 'readline';
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import { spawn } from 'child_process';

// Get directory information
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Configure logging
const LOG_FILE = path.join(__dirname, 'mcp-stdio.log');
function log(message) {
  const timestamp = new Date().toISOString();
  const logMessage = `[${timestamp}] ${message}\n`;
  fs.appendFileSync(LOG_FILE, logMessage);
}

// Start logging
log('MCP STDIO handler starting');
log(`Directory: ${__dirname}`);
log(`Environment: ${JSON.stringify(process.env, null, 2)}`);

// Set up server info for MCP protocol
const serverInfo = {
  name: "MCP Agent Chat",
  version: "1.0.0",
  description: "Chat agent with vector search capabilities",
  vendor: {
    name: "Your Organization"
  },
  capabilities: {
    chat: true,
    vectorSearch: true,
    indexRepository: true
  }
};

// Create an offerings structure
const offerings = {
  tools: [
    {
      id: "chat",
      name: "Chat",
      description: "Process a chat message with repository context",
      parameters: {
        type: "object",
        required: ["message"],
        properties: {
          message: { type: "string", description: "The message to process" },
          repository: { type: "string", description: "Repository to use for context" },
          context: { type: "array", items: { type: "string" }, description: "Additional context" }
        }
      }
    },
    {
      id: "vectorSearch",
      name: "Vector Search",
      description: "Search for code in a repository",
      parameters: {
        type: "object",
        required: ["query", "repository"],
        properties: {
          query: { type: "string", description: "The search query" },
          repository: { type: "string", description: "Repository to search in" },
          limit: { type: "number", description: "Maximum results to return" }
        }
      }
    },
    {
      id: "indexRepository",
      name: "Index Repository",
      description: "Index a repository for search",
      parameters: {
        type: "object",
        required: ["repository"],
        properties: {
          repository: { type: "string", description: "Repository URL to index" },
          branch: { type: "string", description: "Branch to index" }
        }
      }
    }
  ],
  resources: [],
  resourceTemplates: []
};

// Start HTTP server if needed
function startHttpServer() {
  log('Starting HTTP server in background');
  
  const serverProcess = spawn('node', ['server.js'], {
    cwd: __dirname,
    detached: true,
    stdio: 'ignore',
    env: process.env
  });
  
  serverProcess.unref();
  log(`HTTP server spawned with PID ${serverProcess.pid}`);
}

// Try to start the HTTP server in the background
startHttpServer();

// Set up readline interface for stdio communication
const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
  terminal: false
});

// Handle messages from stdin
rl.on('line', (line) => {
  log(`Received: ${line}`);
  
  try {
    const request = JSON.parse(line);
    handleRequest(request);
  } catch (error) {
    log(`Error parsing message: ${error.message}`);
    sendErrorResponse('parse_error', -32700, 'Parse error', null);
  }
});

// Handle request based on method
function handleRequest(request) {
  if (!request.jsonrpc || request.jsonrpc !== '2.0') {
    log('Invalid JSON-RPC request');
    sendErrorResponse('invalid_request', -32600, 'Invalid Request', request.id);
    return;
  }
  
  const { method, id } = request;
  log(`Handling method: ${method}, id: ${id}`);
  
  // Handle different methods
  switch (method) {
    case 'initialize':
    case 'getServerInfo':
      sendResponse({ serverInfo }, id);
      break;
    
    case 'listOfferings':
      sendResponse(offerings, id);
      break;
    
    case 'invokeChat':
    case 'invokeVectorSearch':
    case 'invokeIndexRepository':
      // In a real implementation, these would forward to the HTTP server
      // For now, just acknowledge
      sendResponse({ 
        status: "success", 
        response: "This is a placeholder response from the MCP handler" 
      }, id);
      break;
    
    default:
      log(`Unknown method: ${method}`);
      sendErrorResponse('method_not_found', -32601, `Method not found: ${method}`, id);
  }
}

// Send JSON-RPC response
function sendResponse(result, id) {
  const response = {
    jsonrpc: '2.0',
    result,
    id
  };
  
  log(`Sending response for id ${id}`);
  console.log(JSON.stringify(response));
}

// Send JSON-RPC error response
function sendErrorResponse(name, code, message, id) {
  const response = {
    jsonrpc: '2.0',
    error: {
      code,
      message,
      data: { name }
    },
    id
  };
  
  log(`Sending error response: ${message}`);
  console.log(JSON.stringify(response));
}

// Send server info notification immediately
function sendServerInfoNotification() {
  const notification = {
    jsonrpc: '2.0',
    method: 'serverInfo',
    params: { serverInfo }
  };
  
  log('Sending server info notification');
  console.log(JSON.stringify(notification));
}

// Send initial server info notification
sendServerInfoNotification();

// Handle process termination
process.on('SIGINT', () => {
  log('Received SIGINT, exiting');
  rl.close();
  process.exit(0);
});

process.on('SIGTERM', () => {
  log('Received SIGTERM, exiting');
  rl.close();
  process.exit(0);
});

// Keep the process alive
setInterval(() => {
  log('Heartbeat');
}, 30000);